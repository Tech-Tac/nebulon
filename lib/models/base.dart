class Snowflake {
  /// The first second of 2015 in unix time.
  static const int discordEpoch = 1420070400000;

  factory Snowflake(dynamic input) {
    if (input is int) {
      return Snowflake.fromInt(input);
    } else if (input is String && input.isNotEmpty) {
      return Snowflake.fromInt(int.parse(input));
    } else if (input is Snowflake) {
      return input;
    }
    throw ArgumentError(
      'Cannot convert ${input.runtimeType} "$input" to Snowflake.',
    );
  }

  const Snowflake.fromInt(this.value);

  factory Snowflake.fromDate(DateTime date) =>
      Snowflake.fromInt((date.millisecondsSinceEpoch - discordEpoch) << 22);

  final int value;

  /// The time this id was generated.
  DateTime get date =>
      DateTime.fromMillisecondsSinceEpoch((value >> 22) + discordEpoch);

  /// The worker that generated this id.
  int get internalWorkerId => (value & 0x3E0000) >> 17;

  /// The process that generated this id.
  int get internalProcessId => (value & 0x1F000) >> 12;

  /// An increment for ids generated by the same process.
  int get increment => value & 0xFFF;

  @override
  bool operator ==(Object other) =>
      identical(this, other) || value == Snowflake(other).value;
  bool operator >=(Object other) =>
      identical(this, other) || value >= Snowflake(other).value;
  bool operator <=(Object other) =>
      identical(this, other) || value <= Snowflake(other).value;
  bool operator >(Object other) => value > Snowflake(other).value;
  bool operator <(Object other) => value < Snowflake(other).value;

  @override
  int get hashCode => value;

  @override
  String toString() => value.toString();
}

abstract class Resource {
  const Resource({required this.id});
  final Snowflake id;

  @override
  bool operator ==(Object other) =>
      identical(this, other) || other is Resource && id == other.id;

  @override
  int get hashCode => id.value;
}

abstract class CacheableResource extends Resource {
  const CacheableResource({required super.id});

  /// Update the current instance using values from [other].
  void merge(covariant CacheableResource other);
}

// TODO: deprecate this in favor of GlobalCache
/// A generic registry for a Cacheable type.
class CacheRegistry<T extends CacheableResource> {
  final Map<Snowflake, T> _cache = {};

  /// Returns the existing instance (merging in new values)
  /// or stores and returns the new instance.
  T getOrCreate(T newInstance) {
    final id = newInstance.id;
    if (_cache.containsKey(id)) {
      final existing = getById(id)!;
      existing.merge(newInstance);
      return existing;
    } else {
      put(newInstance);
      return newInstance;
    }
  }

  void put(T instance) {
    _cache[instance.id] = instance;
  }

  T? getById(Snowflake id) {
    return _cache[id];
  }
}

// TODO: use Globalcache for all cacheable resources
class GlobalCache {
  static final Map<Type, Map<Snowflake, Resource>> _cache = {};

  static void insert<T extends Resource>(T resource) {
    _cache[T] ??= {};
    _cache[T]![resource.id] = resource;
  }

  static T? getById<T extends Resource>(Snowflake id) {
    return _cache[T]?[id] as T?;
  }

  static void clearAll() {
    _cache.clear();
  }
}
